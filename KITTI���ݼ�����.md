# KITTI数据及解析

以000000.txt为例

## label2

```
Pedestrian 0.00 0 -0.20 712.40 143.00 810.73 307.92 1.89 0.48 1.20 1.84 1.47 8.41 0.01
```

Pedestrian：目标名称

第2个数：代表物体是否被截断，从0（非截断）到1（截断）浮动，其中truncated指离开图像边界的对象

第3个数：代表物体是否被遮挡，整数0，1，2，3表示被遮挡的程度  0：完全可见 1：小部分遮挡 2：大部分遮挡 3：完全遮挡（unknown）

第4个数：alpha，物体的观察角度，范围：-pi~pi

![img](https://img-blog.csdnimg.cn/20181204101648283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1aWNodWFuY2hlbjMzMDc=,size_16,color_FFFFFF,t_70)

第5～8这4个数：物体的2维边界框，左上角和右下角的像素坐标 （712.40 143.00 810.73 307.92）

第9～11这3个数：3维物体的尺寸，高、宽、长（单位：米）（1.89 0.48 1.20）

第12～14这3个数：3维物体的位置 x,y,z（在照相机坐标系下，单位：米）（1.84 1.47 8.41）

第15个数：3维物体的空间方向：rotation_y，在照相机坐标系下，相对于y轴的旋转角，范围：-pi~pi （0.01）

有些有第16个数：检测的置信度 ， 仅用于结果：浮点，p / r曲线所需，越高越好

## calib解析

要将Velodyne坐标中的点x投影到左侧的彩色图像中y：

使用公式：y = P2 * R0_rect *Tr_velo_to_cam * x

将Velodyne坐标中的点投影到右侧的彩色图像中：

使用公式：y = P3 * R0_rect *Tr_velo_to_cam * x

Tr_velo_to_cam * x  ：是将Velodyne坐标中的点x投影到编号为0的相机（参考相机）坐标系中

R0_rect *Tr_velo_to_cam * x  ：是将Velodyne坐标中的点x投影到编号为0的相机（参考相机）坐标系中，再修正

P2 * R0_rect *Tr_velo_to_cam * x   ：是将Velodyne坐标中的点x投影到编号为0的相机（参考相机）坐标系中，再修正，然后投影到编号为2的相机（左彩色相机）

注意：所有矩阵都存储在主行中，即第一个值对应于第一行。 R0_rect包含一个3x3矩阵，需要将其扩展为4x4矩阵，方法是在右下角添加1，在其他位置添加0。 Tr_xxx是一个3x4矩阵（R | t），需要以相同的方式扩展到4x4矩阵！

通过使用校准文件夹中的3x4投影矩阵，可以将相机坐标系中的坐标投影到图像中，对于提供图像的左侧彩色相机，必须使用P2。rotation_y和alpha之间的区别在于rotation_y直接在相机坐标中给出，而alpha也会考虑从相机中心到物体中心的矢量，以计算物体相对于相机的相对方向。 例如，沿着摄像机坐标系的X轴面向的汽车，无论它位于X / Z平面（鸟瞰图）中的哪个位置，它的rotation_y都为 0，而只有当此车位于相机的Z轴上时α才为零，当此车从Z轴移开时，观察角度α将会改变。

## velodyne解析

点云数据被保存为.bin文件，并且，每一个点包含3个坐标和反射率信息，即(x,y,z,r)，并且数据类型为浮点数类型。











